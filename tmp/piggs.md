Не так давно на Хабре появилась отличная и вдохновляющая статья про компиляторы и стековые машины, в которой автор с читателем проходит путь реинкарнации простой реализации исполнителя байт-кода к всё более и более эффективным версиям. Мне захотелось показать на примере разработки стековой машины, как это можно сделать Haskell-way.

Задачи трансляции и интерпретации дарят множество интересных и полезных примеров для демонстрации самых разных аспектов программирования, позволяя переходить на разные ступени сложности и абстракции, оставаясь при этом вполне практичными. В этой статье я сосредоточусь на демонстрации возможностей двух важных математических структур -- *полугруппы* и *моноида*. Они не настолько на слуху, как монады или линзы, ими не пугают маленьких детей, эти структуры существенно проще для понимания, но при этом они лежат в основе функционального программирования. Виртуозное владение моноидальными типами, которое демонстрируют профессионалы вызывает восхищение простотой и изяществом решений.

Поиск слова "моноид" по статьям на Хабре показывает не более четырёх десятков статей (про монады их три сотни). Все они концептуально начинают так: *моноид это такое множество...* а потом с понятным восторгом перечисляют что является моноидом от строк до пальчиковых деревьев, от парсеров регулярок до бог знает ещё чего! Но на практике мы мыслим в обратном порядке: у нас есть объект, который неомходимо моделировать, мы анализируем его свойства и обнаружив, что он обладает признаками той или иной абстрактной структуры, решаем: нужны ли нам следствия из этого обстоятельства и как нам это использовать. Я хочу пройти именно этим путём. Заодно показать применение ещё парочки интересных новых моноидов.

Статья рассчитана на тех, кто владеет языком Haskell на среднем уровне и выше, на тех, кто его уже использует в работе или исследованиях и на всех любопытных, заглянувших поглядеть чего это функциональщики ещё понаворотили.

<cut />

Стековые машины при изучении функционального программирования, обычно появляются в тот момент, когда подходят к концепции свёртки. При этом приводится крайне лаконичная реализация исполнителя простейшего стекового калькулятора, например, такая:

<spoiler title="Простейший стековый калькулятор">
```haskell
calc :: String -> [Int]
calc = interpretor . lexer
  where
    lexer = words
    interpretor = foldl (flip interprete) []
    interprete c = case c of
      "add" -> binary $ \(x:y:s) -> x + y:s
      "mul" -> binary $ \(x:y:s) -> x * y:s
      "sub" -> binary $ \(x:y:s) -> y - x:s
      "div" -> binary $ \(x:y:s) -> y `div` x:s
      "pop" -> unary  $ \(x:s) -> s
      "dup" -> unary  $ \(x:s) -> x:x:s
      x -> case readMaybe x of
        Just n -> \s -> n:s
        Nothing -> error $ "Error: unknown command " ++ c
      where
        unary f s = case s of
          x:_ -> f s
          _ -> error $ "Error: " ++ c ++ " expected an argument."
        binary f s = case s of
          x:y:_ -> f s
          _ -> error $ "Error " ++ c ++ " expected two arguments."
```
Здесь используется тотальный парсер `readMaybe` из модуля `Text.Read`. Можно было бы привести программу и раза в два короче, но уже без информативных сообщениях об ошибках, а это некрасиво.
</spoiler>

Прекрасное начало для разговора! Далее обычно начинают навешивать эффекты: меняют свёртку `foldl` на `foldM`, обеспечивают тотальность через монаду `Either String`, потом добавляют логирование, оборачивая всё трасформером `WriterT`, внедряют с помощью `StateT`  словарь для переменных, и так далее. Иногда, для демонстрации крутости монадических вычислений, реализуют неоднозначный калькулятор, возвращающий все возможные значения выражения $inline$(2\pm3)*(4\pm(8\pm 5))$inline$. Это долгий, хороший и интересный разговор, но свой рассках мы сразу поведём по-другому.

Почему, вообще, речь зашла о свёртке? Потому что свёртка (катаморфизм) -- это абстракция последовательной обработки индуктивных данных. Стековая машина линейно проходит по коду, выполняя последовательность инструкций и порождает одно значение -- состояние стека. Мне нравится представлять себе работу свёрточной стековой машины, как трансляцию матричной РНК в живой клетке. Рибосома шаг за шагом проходит всю цепочку РНК, сопоставляет триплеты нуклеотидов с аминокислотами и [создаёт](https://youtu.be/8dsTvBaUMvw) первичную структуру белка. 

Но у свёрточной машины есть ряд ограничений, основное -- программа всегда прочитывается от начала до конца и один раз. Ветвление, переходы и циклы требуют концептуального изменения интерпретатора. Ничего сложного, конечно, но такая машина уже не может быть описана простой свёрткой.

Но давайте посмотрим не на машину, а на языки, которыми она управляется. Все стеково-ориентированные языки, как относительно низкоуровневые, такие как байт-коды виртуальных машин Java и Python или Common Intermediate Language в платформе .NET, так и языки уровнем повыше -- PostScript, Forth или Joy, имеют одно фундаментальное общее свойство: если соединить (записать последовательно) две корректные программы, то получится корректная программа. Правда, корректная не значит "правильная", эта программа может вылетать с ошибкой на любых данных или проваливаться в бесконечные циклы и вообще не иметь смысла, но главное -- такая программа сможет быть выполнена машиной. В то же время, разбивая корректную программу на части мы легко можем эти части использовать повторно, именно в силу их корректности. Наконец, в любом стековом языке можно выделить подмножество команд, оперирующих только стеком, не использующих регистры или другую внешнюю память. Это подмножество будет образовывать язык, обладающий свойством *конкатенативности*. В таком языке любая программа имеет смысл преобразователя стека, а последовательное выполнение программ эквивалентно их композиции, а значит, тоже является преобразователем стека.

Просматривается общий паттерн: комбинация (конкатенация) корректных программ порождает корректную программу, комбинация преобразователей порождает преобразователь. Получается, что программы стековых языков замкнуты относительно операции конкатенации или образуют структуру, которая называется *группоидом* или *магмой*. То есть, можно, записав программу на ленту, ножницами разрезать её почти как попало и потом из полученных отрезков формировать новые программы. Причём разрезать можно вплоть до длины одной инструкции.

При склеивании важен порядок: программы `5 dup pop` и `5 pop dup`, несомненно, разные. Зато неважно где программу разрезать, если тут же её в этом месте склеить. Это значит, что программы `5 dup` $inline$\diamond$inline$ `pop` и `5` $inline$\diamond$inline$ `dup pop` эквивалентны.  Это простое обстоятельство отражает *ассоциативность* операции конкатенации и поднимает структуру, которую образуют стековые программы, на новый уровень, мы понимаем что это полугруппа!

И что это нам даёт, как программистам? Ассоциативность позволяет выполнять прекомпиляцию, оптимизацию и даже распараллеливание произвольных пригодных для этого отрезков программы, объединяя их в эквивалентную программу. Мы можем позволить себе провести статический анализ любого отрезка программы (провести анализ согласованности типов или арности) и использовать его в анализе всей программы именно потому что нам всё равно, где ставить скобки. Это очень важные и серьёзные возможности для языка низкого уровня или промежуточного языка, на котором пишет не человек, а транслятор. А с точки зрения математика, и матёрого функциональщика, это делает программы-преобразователи стека полноценными *эндоморфизмами*, -- отображение множества в себя, которые образуют полугруппу относительно операции композиции. 

"Полугруппа" звучит половинчато, как-то неполноценно. Может быть, стековые программы образуют группу? Группой является множество, замкнутое относительно ассоциативной бинарной операции, причём для этой операции имеется нейтральный элемент, и каждый элемент множества имеет обратный.

Э.. нет, большинство программ необратимо, то есть по результату выполнения не догадаешься какими были исходные данные. А вот нейтральный элемент у нас есть. В языках ассемблера он обозначается `nop` и ничего не делает. Если в стековом языке такого оператора явно не определили, то его можно легко получить комбинируя некоторые команды, например: `inc dec`, `dup pop` или `swap swap`. Такие пары можно безболезненно вырезать из программ или, напротив, вставлять куда угодно в произвольном количестве. Поскольку единица имеется, наши программы образуют *полугруппу с единицей* или *моноид*. Значит, можно програмно реализовать их в виде моноидов -- эндоморфизмов над состоянием стековой машины. Это позволит определить небольшой набор базовых операций для машины, а потом создавать программы с помощью их композиции, получив стековый язык в форме EDSL (встроенного предметно-ориентированного языка).

###Первая версия. Начало.

<spoiler title="Заголовочная часть">
```haskell
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Pig0 where

import Data.Semigroup (Max(..),stimes, Semigroup(..))
import Data.Monoid hiding ((<>))
```
</spoiler>

Начнём с определения типа для состояния машины и тривиальной функции-сеттера. 

```haskell
type Stack = [Int]
type Processor = VM -> VM

data VM = VM { stack :: Stack }
  deriving Show

mkVM = VM mempty

setStack :: Stack -> Processor
setStack  x (VM _) = VM x
```
Этот сеттер нужен для того, чтобы сделать явной семантику программы. Под процессором (тип `Processor`) мы будем понимать преобразователь состояния виртуальной машины. Теперь определим тип для программы, умный конструктор и исполнитель:

```haskell
newtype Program = Program { getProgram :: Dual (Endo VM) }
  deriving (Semigroup, Monoid)

program :: (Stack -> Processor) -> Program
program f = Program . Dual . Endo $ 
  \vm -> f (stack vm) vm

run :: Program -> Processor
run = appEndo . getDual . getProgram
```

Типы-обёртки `Endo` и `Dual` нужны для для содания эндоморфизма и обеспечения нужного порядка выполнения программы (слева направо). Их использование позволяет компилятору самостоятельно определить каким образом тип `Program` реализует требования классов `Semigroup` и `Monoid`. 
 
Теперь можно определять команды языка:
```haskell
pop = program $ 
  \case x:s -> setStack s
        _ -> error "pop expected an argument."

push x = program $ \s -> setStack (x:s)

dup = program $ 
  \case x:s -> setStack (x:x:s)
        _ -> error "dup expected an argument."
```

А вот как будут выглядеть и работать простейшие программы:

```haskell
λ> run (push 6 <> dup) mkVM
VM {stack = [6,6]}
λ> run (push 6 <> dup <> pop) mkVM
VM {stack = []}
```
Программу можно задавать списком, а потом склеивать его функцией `mconcat`, определённой для моноидов:

```haskell
λ> run (mconcat [push 6, push 5, dup] mkVM
VM {stack = [5,5,6]}
```

Добавим побольше базовых операторов для работы со стеком, целочисленную арифметику и отношения эквивалентности и порядка.

<spoiler title="Прочие операторы">
```haskell
swap = program $ 
  \case x:y:s -> setStack (y:x:s)
        _ -> error "swap expected two arguments."

exch = program $ 
  \case x:y:s -> setStack (y:x:y:s)
        _ -> error "exch expected two arguments."

app1 n f = program $
  \case x:s -> setStack (f x:s)
        _ -> error $ "operation " ++ show n ++ " expected an argument"

app2 n f = program $
  \case x:y:s -> setStack (f x y:s)
        _ -> error $ "operation " ++ show n ++ " expected two arguments"

add = app2 "add" (+)
sub = app2 "sub" (flip (-))
mul = app2 "mul" (*)
frac = app2 "frac" (flip div)
neg = app1 "neg" (\x -> -x)
inc = app1 "inc" (\x -> x+1)
dec = app1 "dec" (\x -> x-1)
eq = app2 "eq" (\x -> \y -> if (x == y) then 1 else 0)
neq = app2 "neq" (\x -> \y -> if (x /= y) then 1 else 0)
lt = app2 "lt" (\x -> \y -> if (x > y) then 1 else 0)
gt = app2 "gt" (\x -> \y -> if (x < y) then 1 else 0)
```
</spoiler>

Для полноценной работы не хватает ветвления и циклов. Вообще-то, для встроенного языка достаточно только ветвления, циклы можно организовать с помощью рекурсии, но мы сделаем наш язык самодостаточным. 

```haskell
proceed :: Program -> Stack -> Processor
proceed prog s = run prog . setStack s

branch :: Program -> Program -> Program
branch br1 br2 = program go
   where go (x:s) = proceed (if (x /= 0) then br1 else br2) s
         go _ = error "branch expected an argument."

while :: Program -> Program -> Program
while test body = program (const go) 
  where go vm = let res = proceed test (stack vm) vm
          in case (stack res) of
               0:s -> proceed mempty s res
               _:s -> go $ proceed body s res
               _ -> error "while expected an argument." vm
```
Типы функций `branch` и `while` говорят о том, что это не самостоятельные программы, а комбинаторы программ: типичный подход при создании EDSL в Haskell. 

А ещё давайте воспользуемся тем, что программы это полугруппы и определим комбинатор повторения выполнения программы указанное число раз. Количество повторений он будет брать со стека.
```haskell
rep :: Program -> Program
rep body = program go
  where go (n:s) = proceed (stimes n body) s
        go _ = error "rep expected an argument."
```
Функция `stimes` определена для всех полугрупп, она возвращает композицию указанного числа элементов.
Наконец, напишем несколько программ, для опытов.
```haskell
-- рекурсивный факториал
fact = dup <> push 2 <> lt 
     <> branch (push 1) 
	           (dup <> dec <> fact) 
     <> mul

-- итеративный факториал
fact1 = push 1 <> swap 
     <> while (dup <> push 1 <> gt) 
	          (swap <> exch <> mul <> swap <> dec) 
	 <> pop

-- заполняет стек последовательностью чисел
-- в указанном диапазоне
range = exch <> sub <> rep (dup <> inc)

-- ещё один итеративный факториал
fact2 = mconcat [ dec, push 2, swap, range
                , push 3, sub, rep mul]

-- копирует два верхних элемента стека
copy2 = exch <> exch

-- вычисляет наибольший общий делитель 
-- по простейшему алгоритму Евклида
gcd1 = while (copy 2 <> neq) 
             (copy 2 <> lt 
	   		  <> branch (mempty) 
			            (swap) 
	          <> exch <> sub) 
	   <> pop
```
Работает?

```haskell
λ> run (push 6 <> fact) mkVM
VM {stack = [720]}
λ> run (push 2 <> push 6 <> range) mkVM
VM {stack = [6,5,4,3,2]}
λ> run (push 6 <> push 9 <> gcd1) mkVM
VM {stack = [3]}
```

На самом деле, мы ничего нового не сделали -- комбинируя преобразователи-эндоморфизмы, мы, по существу, вернулись к свёртке, но она стала неявной.

###Вторая версия. Ошибки.

Следующим шагом избавимся от нетотальности базовых программ, постаравшись менять как можно меньше в написанном коде. Для этого добавим в машину поле состояния, которое будет хранить сообщение об ошибке и служить сигналом к завершению выполнения программы.

<spoiler title="Заголовочная часть">
```haskell
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Pig1 where

import Prelude hiding (error)
import Data.Semigroup (Max(..),stimes, Semigroup(..))
import Data.Monoid hiding ((<>))
```
</spoiler>


```haskell
data VM = VM { stack :: Stack
             , status :: Maybe String }
          deriving Show

mkVM = VM mempty mempty

setStack :: Stack -> Processor
setStack  x (VM _ s) = VM x s

setStatus :: Maybe String -> Processor
setStatus x (VM s _) = VM s x
```
Надо ещё модифицировать конструктор программ так, чтобы они продолжали выполнение только в отстутствие ошибки:
```haskell
program :: (Stack -> Processor) -> Program
program f = Program . Dual . Endo $
  \vm -> case status vm of
    Nothing -> (f (stack vm)) vm
    m -> vm
```
И определим новую функцию, генерирующую ошибку, которая становится рядовым процессором:
```haskell
error :: String -> Processor
error m = setStatus . Just $ "Error : " ++ m
```
В заголовке мы не стали импортировать из модуля `Prelude` стандартную функцию `error`, заменив её своей. Всё, больше ничего в коде менять не надо, наш встроенный язык стал "правильным", то есть, лишённым побочных эффектов.
```haskell
λ> run (push 6 <> fact) mkVM
VM {stack = [720], status = Nothing}
λ> run (push 2 <> push 6 <> range) mkVM
VM {stack = [6,5,4,3,2], status = Nothing}
λ> run (push 9 <> gcd1) mkVM
VM {stack = [9], status = Just "Error! exch expected two arguments"}
```

###Третья версия. Память.

Добавим нашей машине быстрой и удобной памяти, опять же как можно более стерильным образом.

<spoiler title="Заголовочная часть">
```haskell
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
module Pig1 where

import Prelude hiding (error)
import Data.Semigroup (Max(..),stimes, Semigroup(..))
import Data.Monoid hiding ((<>))
import Data.Vector ((//),(!),Vector)
import qualified Data.Vector as V (replicate)
```
</spoiler>

```haskell
type Stack = [Int]
type Memory = Vector Int
type Processor = VM -> VM

memSize = 8

data VM = VM { stack :: Stack
             , status :: Maybe String
             , memory :: Memory }
          deriving Show

mkVM = VM mempty mempty (V.replicate memSize 0)

setStack :: Stack -> Processor
setStack  x (VM _ s m) = VM x s m

setStatus :: Maybe String -> Processor
setStatus x (VM s _ m) = VM s x m

setMemory :: Memory -> Processor
setMemory x (VM s st _) = VM s st x
```

Для работы с памятью определим специальный конструктор програм, так чтобы не пришлось менять уже написанные код. 

```haskell
programM :: ((Memory, Stack) -> Processor) -> Program
programM f = Program . Dual . Endo $
  \vm -> case status vm of
    Nothing -> (f (memory vm, stack vm)) $ vm
    m -> vm
```

После этого можно создать два новых оператора: записи в память значения, лежащего на вершине стека, и чтения из памяти.

```haskell
put i = indexed i $
    \case (m, x:s) -> setStack s . setMemory (m // [(i,x)])
          _ -> error "put expected an argument"

get i = indexed i $ \(m, s) -> setStack ((m ! i) : s)

indexed i f = programM $ if (i < 0 || i >= memSize)
                         then const $ error "exprcted index in [0,8]"
                         else f
```

Можно добавить в коллекцию новую программу, вычисляющую факториал с использованием памяти.

```haskell
fact3 = dup <> put 0 <> dup <> dec 
     <> rep (dec <> dup <> get 0 <> mul <> put 0) 
	 <> get 0 <> swap <> pop
```

```haskell
λ> run (push 6 <> fact3) mkVM
VM {stack = [720], status = Nothing, memory = [720,0,0,0,0,0,0,0]}
```

###Четвёртая версия. Логирование.

###Пятая версия. Освобождение моноида.

###Статический анализ.

