function Histogram(s)
{
    this.isHistogram = true
    this.step = s || 1
    this.data = {}
    this.bins = []
    this.total = 0
    this.number = 0
    this.mode = undefined
    this.antimode = undefined
    this.minBin = 1/0
    this.maxBin = -1/0
    this.minValue = 1/0
    this.maxValue = 0
    
    this.fromList = function (lst)
    {
	lst.forEach(x => this.add(x))
	return this
    }

    this.fromDistribution = function (dist,n)
    {
	return this.fromList(dist.samples(n))
    }

    
    this.add = function (x,n)
    {
	var n = n || 1

	var bin
	if (this.step == 'none')
	    bin = x
	else
	    bin = floor(x/this.step)*this.step+this.step/2
	this.bins = this.bins.add(bin)
	this.total += x
	this.number += n
	this.data[bin] = this.data[bin] + n || n
	this.maxBin = max(this.maxBin,bin)
	this.minBin = min(this.minBin,bin)
	this.maxValue = max(this.maxValue,this.data[bin])
	this.minValue = min(this.minValue,this.data[bin])
	if (this.mode == undefined) this.mode = bin
	if (this.data[this.mode] < this.data[bin])
	    this.mode = bin
	if (this.antimode == undefined) this.antimode = bin
	if (this.data[this.antimode] > this.data[bin])
	    this.antimode = bin
	this.quantileData = null
	return this
    }
       
    this.PDF = function(x)
    {
	var bin
	if (x < this.minBin-this.step/2)
	    return 0
	if (x > this.maxBin+this.step/2)
	    return 0
	if (this.step == 'none')
	    bin = x
	else
	    bin = floor(x/this.step)*this.step+this.step/2
	return this.data[bin]/this.number/this.step
    }

    this.quantileData = null
    this.quantileFun = null
    this.CDFFun = null
    this.buildQuantiles = function()
    {
	var res = this.bins
	    .map(b => this.data[b])
	    .accumsum()
	
	this.quantileData = res
	    .map(x => x/res[res.length-1])
	    .zip(this.bins.map(x => x-this.step/2))
	this.quantileFun = linearInterpolation(this.quantileData)
	this.CDFFun = linearInterpolation(this.quantileData.map(x=>x.reversed()))
    }

    this.CDF = function(x)
    {
	if (this.quantileData == null)
	    this.buildQuantiles()
	if (x <= this.minBin) return 0
	if (x >= this.maxBin) return 1
	return this.CDFFun(x)
	//return this.quantileData.find(([q,b]) => x <= b)[0]
    }
    
    this.quantile = function(x)
    {
	if (this.quantileData == null)
	    this.buildQuantiles()
	if (x <= 0) return null
	if (x >= 1) return null
	return this.quantileFun(x)
	//var res = this.quantileData.find(([q,b]) => x <= q)
	//return res && res[1]
    }

    this.quantiles = function()
    {
	if (this.quantileData == null)
	    this.buildQuantiles()
	return this.quantileData
    }   
}

isHistogram = function (x) {
    return (typeof x == 'object') && x.isHistogram || false
}

Object.defineProperty
(Histogram.prototype, "mean",
 { get : function ()
   {
       return this.total/this.number
   }
 }
)

Object.defineProperty
(Histogram.prototype, "median",
 { get : function ()
   {
       return this.quantile(1/2)
   }
 }
)


Object.defineProperty
(Histogram.prototype,
 "variance",
 { get : function ()
   {
	var res = 0, m = this.mean
	for(var b in this.data)
	    res += (b - m)*(b - m)*this.data[b]
	return res/this.number
   }
 }
)

Object.defineProperty
(Histogram.prototype,
 "stdev",
 { get : function ()
   {
	return sqrt(this.variance) 
   }
 }
)

Object.defineProperty
(Histogram.prototype,
 "LorenzCurve",
 { get : function ()
   {
       var res = [[0,0]], x = 0, y = 0
       this.bins.forEach(b => res.push([x+=this.data[b],y+=this.data[b]*b]))
       return res.map(r => [r[0]/x,r[1]/y])
   }
 }
)

Histogram.prototype.sumf = function(f)
{
    var res = 0, y
    for(var b in this.data)
    {
	y = f(b)
	if (isNaN(y) || y == null) continue
	res += f(b)*this.data[b]
    }
    return res
}

Histogram.prototype.meanf = function(f)
{
    return this.sumf(f)/this.number
}


Histogram.prototype.quantilePlot = function (data)
{
    if (Array.isArray(data)) {
	return this.quantilePlot(new Histogram(this.step).fromList(data))
    }
    if (isDistribution(data)) {
	if (data.quantile == 'not implemented')
	    return this.quantilePlot(data.samples(this.number)) 
	else
	    return [this.quantiles()
		    .map(([q,b]) => [data.quantile(q),b])
		    .filter(([a,b]) => !(a == null || a == Infinity || isNaN(a))),
		    data]
    }
    if (typeof data== 'function' && isDistribution(data())) {
	return this.quantilePlot(data().fromHistogram(this))
    }
    if (isHistogram(data)) {
	var l1 = data.quantiles().map(([q,b]) => [b,this.quantile(q)])
	var l2 = this.quantiles().map(([q,b]) => [data.quantile(q),b])
	return [l1.merge(l2).filter(([a,b]) => a != null && b != null),
		data]
    }
}

Histogram.prototype.QQPlot = function (data, opts)
{
    var defaults = {
	axisType  : 'linear',
	show  : 'values',
	quantiles : [0.01,0.1,0.25,0.5,0.75,0.9,0.99] 
    }
    var options = Object.assign(defaults, opts || {})    

    var qq,f
    [qq,f] = this.quantilePlot(data)
    var qs = options.quantiles
    var res = new Graphics(fig1, opts)
    if (options.axesType == 'log')
    {
	qq = qq.filter(([a,b]) => a > 0 & b > 0)
	res.xAxisType('log').yAxisType('log')
    }
    res .listPlot(qq, {'class':'QQdata'})
	.plot(x => x, {'class':'QQdiagonal'})
    	.gridLines({x : qs.map(x => f.quantile(x)),
		    y : qs.map(x=> this.quantile(x))})

    if (options.show == 'quantiles')
	res.axes({xTickValues : qs.map(x => f.quantile(x)),
		  xTickFormat : d => fmt.percent(f.CDF(d)),
		  yTickValues : qs.map(x => this.quantile(x)),
		  yTickFormat : d => fmt.percent(this.CDF(d))})
    else
	return res.axes({})
    
}

// EXAMPLE
/*
new Graphics(fig1)
    h.QQPlot(Geometric)
*/

function ContinuousDistribution(par)
{
    var res = {parameters : par}
    res.isDistribution = true
    res.isDiscrete = false
    res.support   = undefined
    res.PDF = undefined
    res.CDF       = cdf(res,x => integrate(res.PDF,[0,x]))
    res.quantile  = quantileFun(q => newton(x => res.CDF(x) - q,res.PDF,res.mean))
    res.mean      = undefined
    res.median    = undefined
    res.variance  = undefined
    res.stdev     = sqrt(res.variance)	
    res.mode      = undefined
    res.generator = undefined
    res.samples   = n => d3.range(n).map(res.generator)
    res.fromHistogram  = undefined
    res.fromList = lst => this.fromHistogram(new Histogram().fromList(lst))
    return res
}

function DiscreteDistribution(par)
{
    var res = {parameters : par}
    res.isDistribution = true
    res.isDiscrete = true
    res.support   = undefined
    res.PMF = undefined
    res.CDF       = cdf(res,x => range(0,x).sum(res.PMF))
    res.quantile  = quantileFun(q => findRoot(res.CDF,0,x => x <= q)[0])
    res.mean      = undefined
    res.median    = undefined
    res.variance  = undefined
    res.stdev     = sqrt(res.variance)	
    res.mode      = undefined
    res.generator = undefined
    res.samples   = n => d3.range(n).map(res.generator)
    res.fromHistogram  = undefined
    res.fromList = lst => this.fromHistogram(new Histogram().fromList(lst))
    return res
}


isDistribution = function (x) {
    return (typeof x == 'object') && x.isDistribution || false
}

function Gamma(a,b)
{
    var res = ContinuousDistribution({
	shape : a || 1,
	rate  : b || 1
    })
    res.support   = [0,Infinity]
    res.PDF = pdf(res,function (x)
    {
	if (x <= 0) return 0
	return pow(b,a)/gamma(a)*pow(x,a-1)*exp(-b*x)
    })
    res.mean      = a / b
    res.median    = res.mean*(3*a-0.8)/(3*a+0.2)
    res.variance  = a / sqr(b)
    res.mode      = a >= 1 ? (a - 1)/b : 0
    res.generator = gammaGen(a,b)
    res.fromHistogram  = function (h)
    {
	var s1 = h.meanf(log)
	var s = log(h.mean) - s1,
	    a = (3 - s + sqrt((s-3)*(s-3)+24*s))/(12*s),
	    b = a/h.mean
	return Gamma(a, b)
    }
    return res
}

function gammaGen(a,b)
{
    return function ()
    {
	// Gamma(alpha,lambda) generator using Marsaglia and Tsang method
	// Algorithm 4.33
	var randn = d3.randomNormal(0,1), rand = random
	if (a>1)
	{
	    var d=a-1/3,
		c=1/sqrt(9*d),
		flag = true,
		Z,V,U
	    while (flag)
	    {
		Z = randn()
		if (Z>-1/c)
		{
		    V=pow(1 + c*Z, 3)
		    U=rand()
		    flag = log(U) > (Z*Z/2 + d - d*V + d*log(V))
		}
	    }
	    return d*V/b;
	}
	else
	{
	    return gammaGen(a+1,b)()*pow(random(),1/a);
	}
    }
}

function Exponential(l)
{
    var res = ContinuousDistribution({
	rate : l || 1
    })
    res.support  = [0,Infinity]
    res.PDF      = pdf(res,x => l*exp(-x*l))
    res.CDF      = cdf(res,x => 1 - exp(-l*x))
    res.quantile = quantileFun(x => -log(1-x)/l)
    res.mean     = 1/l
    res.median   = log(2)/l
    res.variance = 1/l/l
    res.stdev    = 1/l
    res.mode     = 0
    res.generator = () => -log(random())/l
    res.fromHistogram = h => Exponential(1/h.mean)
    return res
}

function Poisson(l)
{
    var res = DiscreteDistribution({
	    rate : l || 1
    })
    res.support  = [0,Infinity]
    res.PMF      = pdf(res,function (k) {
	var x = floor(k)
	return pow(l,x)*exp(-l)/fact(x)
    })
    res.CDF      = cdf(res,k => exp(-l)*sum(i => pow(l,i)/fact(i),0,floor(k)))
    res.support  = [0,Infinity]
    res.mean     = l
    res.median   = floor(l + 1/3 - 0.02/l)
    res.variance = l
    res.mode     = floor(l)
    res.generator = function ()
    {
	var p = 1, n = 0;
	while (p > exp(-l))
	{
	    p *= random()
	    n++
	}
	return n-1
    }
    res.fromHistogram = h => Poisson(h.mean)
    return res
}

function Normal(m,v)
{
    var s = sqrt(v)
    var res = ContinuousDistribution({
	mean : m || 0,
	variance  : v || 1
    })
    res.PDF = x => sqrt(0.5/pi/v)*exp(-(x-m)*(x-m)/(2*v))
    res.CDF       = x => 1/2*(1 + erf((x-m)/(s*sqrt(2))))
    res.support   = [-Infinity,Infinity]
    res.mean      = m  
    res.median    = m 
    res.variance  = s*s 
    res.stdev     = s 
    res.mode      = m 
    res.generator = d3.randomNormal(m,s)
    res.fromHistogram = h => Normal(h.mean,h.variance)
    return res
}

function LogNormal(m,v)
{
    var s = sqrt(v)
    var res = ContinuousDistribution({
	mean : m || 1,
	variance  : v || 1
    })
    res.support   = [0,Infinity]
    res.PDF       = pdf(res,x => 1/(x*s*sqrt(2*pi))*exp(-sqr(log(x)-m)/(2*v)))
    res.CDF       = cdf(res,x => 1/2*(1 + erf((log(x)-m)/(s*sqrt(2)))))
    res.mean      = exp(m + v/2)  
    res.median    = exp(m) 
    res.variance  = (exp(v) - 1)*exp(2*m+v)
    res.stdev     = s
    res.mode      = exp(m - v)
    res.generator = 'not implemented'
    res.fromHistogram = function (h)
    {
	var m = h.meanf(log)
	var s = sqrt(h.meanf(x => sqr(log(x) - m)))
	return LogNormal(m,s)
    }
    return res
}

function Pareto(k,a)
{
    var res = ContinuousDistribution({
	scale : k || 1,
	shape  : a || 1
    })
    res.support   = [k,Infinity]
    res.PDF = pdf(res,function (x)
    {
	if (x < k) return 0
	return a*pow(k,a)/pow(x,a+1)
    })
    res.CDF = cdf(res,function (x)
    {
	if (x < k) return 0
	return 1 - pow(k/x,a)
    })
    res.quantile  = quantileFun(q => k*pow(1-q,-1/a))
    res.mean      = (a <= 1) ? Infinity : a*k/(a-1)
    res.median    = k*pow(2,1/a)
    res.variance  = (a <= 2) ? Infinity : a*k*k/(sqr(a-1)*(a-2))
    res.mode      = k
    res.generator = () => k/pow(random(),1/a)
    res.samples   = n => d3.range(n).map(res.generator)
    res.fromHistogram = h => Pareto(h.minBin,1/h.meanf(x => log(x) - log(h.minBin)))
    return res   
}

function Uniform([a,b])
{
    var res = ContinuousDistribution({
	domain : [a,b] || [0,1]
    })
    res.support   = [a,b]
    res.PDF = pdf(res,x => 1)
    res.CDF = cdf(res,d3.scaleLinear().range([0,1]).domain([a,b]))
    res.quantile  = quantileFun(d3.scaleLinear().range([a,b]).domain([0,1]))
    res.mean      = (b + a)/2
    res.median    = res.mean
    res.variance  = 1/12*sqr(b - a)
    res.mode      = undefined
    res.generator = () => random()*(b-a)+a
    res.fromHistogram = h => Uniform([h.minBin,h.maxBin])
    return res   
}

function Bernoulli(p)
{
    var res = DiscreteDistribution({
	probability : p || 0.5
    })
    var q = 1 - p
    res.support   = [0,1]
    res.PMF = pdf(res, x => x == 0 ? q : p)
    res.CDF = cdf(res,x => q)
    res.mean      = p
    res.median    = (q > p) ? 0 : (q == p) ? 0.5 : 1
    res.variance  = p * q
    res.mode      = (q > p) ? 0 : (q == p) ? undefined : 1
    res.generator = () => Math.random() < p ? 0 : 1
    res.fromHistogram = h => Bernoulli(h.data[1])
    return res   
}

function Geometric(p)
{
    var res = DiscreteDistribution({
	'p' : p || 0.5
    })
    var q = 1 - p
    res.support   = [1,Infinity]
    res.PMF = pdf(res, k => pow(q,floor(k)-1)*p)
    res.CDF = cdf(res, k => 1 - pow(q,k))
    res.quantile  = quantileFun(x => ceil(log(1-x)/log(q)))
    res.mean      = 1/p
    res.median    = ceil(-log(2)/log(1-p))
    res.variance  = q/sqr(p)
    res.mode      = 1
    res.generator = () => ceil(log(Math.random())/log(q))
    res.fromHistogram = h => Geometric(1/h.mean)
    return res   
}


function Bag(lst)
{
    this.contents = lst
    this.sample   = () => {
	if (this.contents.length == 0)
	    return null
	var i = floor(random()*this.contents.length)
	var res = this.contents[i]
	this.contents = this.contents.removeAt(i)
	return res
    }
    this.samples = n =>
    {
	if (this.contents.length == 0)
	    return null
	return d3.range(min(n,this.contents.length)).map(this.sample)
    }
}


function quantileFun(f)
{
    return x =>
	(x >= 0 && x < 1) ? f(x) : undefined
}

function pdf(self,f)
{
    return x =>
	(x >= self.support[0] && x <= self.support[1]) ? f(x) : 0
}

function cdf(self,f)
{
    return x =>
	(x <= self.support[0] ? 0 :
	 x >= self.support[1] ? 1 :
	 f(x))
}


function PoissonProcess(l)
{
    var g = Exponential(l).generator
    var T = g()
    return () => {
	if (T > 0)
	{
	    T--
	    return 0
	}
	else
	{
	    T = g()
	    return 1
	}
    }
}

function RandomWalk(opts)
{
    var g = opts && opts.generator || d3.randomNormal(0,1)
    var x = opts && opts.start || 0;
    var xmax = opts && opts.limit || Infinity
    return () => { return x = max(-xmax, min(xmax, x + g())) }
}

function dice(states)
{
    return () => states[floor(random()*states.length)]
}

function randomInteger(n)
{
    return () => floor(random()*n)
}


